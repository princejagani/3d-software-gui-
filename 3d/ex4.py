# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'ex4.ui'
#
# Created by: PyQt5 UI code generator 5.15.7
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


# from PyQt5 import QtCore, QtGui, QtWidgets


# class Ui_Form(object):
#     def setupUi(self, Form):
#         Form.setObjectName("Form")
#         Form.resize(640, 480)
#         self.widget = QtWidgets.QWidget(Form)
#         self.widget.setGeometry(QtCore.QRect(50, 80, 481, 251))
#         self.widget.setStyleSheet("background-color: rgb(255, 255, 127);")
#         self.widget.setObjectName("widget")
#         self.verticalLayout = QtWidgets.QVBoxLayout(self.widget)
#         self.verticalLayout.setContentsMargins(0, 0, 0, 0)
#         self.verticalLayout.setObjectName("verticalLayout")
#         self.horizontalLayout = QtWidgets.QHBoxLayout()
#         self.horizontalLayout.setObjectName("horizontalLayout")
#         self.verticalLayout.addLayout(self.horizontalLayout)
#         self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
#         self.horizontalLayout_2.setObjectName("horizontalLayout_2")
#         self.verticalLayout.addLayout(self.horizontalLayout_2)

#         self.retranslateUi(Form)
#         QtCore.QMetaObject.connectSlotsByName(Form)

#     def retranslateUi(self, Form):
#         _translate = QtCore.QCoreApplication.translate
#         Form.setWindowTitle(_translate("Form", "Form"))


# if __name__ == "__main__":
#     import sys
#     app = QtWidgets.QApplication(sys.argv)
#     Form = QtWidgets.QWidget()
#     ui = Ui_Form()
#     ui.setupUi(Form)
#     Form.show()
#     sys.exit(app.exec_())


# from PyQt5.QtCore import QDir, Qt, QUrl
# from PyQt5.QtMultimedia import QMediaContent, QMediaPlayer
# from PyQt5.QtMultimediaWidgets import QVideoWidget
# from PyQt5.QtWidgets import (QApplication, QFileDialog, QHBoxLayout, QLabel,
#         QPushButton, QSizePolicy, QSlider, QStyle, QVBoxLayout, QWidget)
# from PyQt5.QtWidgets import QMainWindow,QWidget, QPushButton, QAction
# from PyQt5.QtGui import QIcon
# import sys

# class VideoWindow(QMainWindow):

#     def __init__(self, parent=None):
#         super(VideoWindow, self).__init__(parent)
#         self.setWindowTitle("PyQt Video Player Widget Example - pythonprogramminglanguage.com") 

#         self.mediaPlayer = QMediaPlayer(None, QMediaPlayer.VideoSurface)

#         videoWidget = QVideoWidget()

#         self.playButton = QPushButton()
#         self.playButton.setEnabled(False)
#         self.playButton.setIcon(self.style().standardIcon(QStyle.SP_MediaPlay))
#         self.playButton.clicked.connect(self.play)


#         self.mediaPlayer.setVideoOutput(videoWidget)
#         self.mediaPlayer.stateChanged.connect(self.mediaStateChanged)
#         self.mediaPlayer.positionChanged.connect(self.positionChanged)
#         self.mediaPlayer.durationChanged.connect(self.durationChanged)
#         self.mediaPlayer.error.connect(self.handleError)

#         self.positionSlider = QSlider(Qt.Horizontal)
#         self.positionSlider.setRange(0, 0)
#         self.positionSlider.sliderMoved.connect(self.setPosition)

#         self.mediaPlayer.setMedia(
#                     QMediaContent(QUrl.fromLocalFile("icon/video2.avi")))
#         self.playButton.setEnabled(True)

#         wid = QWidget(self)
#         self.setCentralWidget(wid)
#         controlLayout = QHBoxLayout()
#         controlLayout.setContentsMargins(0, 0, 0, 0)
#         controlLayout.addWidget(self.playButton)
#         controlLayout.addWidget(self.positionSlider)
        
#         layout = QVBoxLayout()
#         layout.addWidget(videoWidget)
#         layout.addLayout(controlLayout)
#         # layout.addWidget(self.errorLabel)
#         wid.setLayout(layout)
#     def play(self):
#             if self.mediaPlayer.state() == QMediaPlayer.PlayingState:
#                 self.mediaPlayer.pause()
#             else:
#                 self.mediaPlayer.play()
#     def setPosition(self, position):
#         self.mediaPlayer.setPosition(position)
#     def mediaStateChanged(self, state):
#         if self.mediaPlayer.state() == QMediaPlayer.PlayingState:
#             self.playButton.setIcon(
#                     self.style().standardIcon(QStyle.SP_MediaPause))
#         else:
#             self.playButton.setIcon(
#                     self.style().standardIcon(QStyle.SP_MediaPlay))

#     def positionChanged(self, position):
#         self.positionSlider.setValue(position)

#     def durationChanged(self, duration):
#         self.positionSlider.setRange(0, duration)
#     def handleError(self):
#         self.playButton.setEnabled(False)
#         self.errorLabel.setText("Error: " + self.mediaPlayer.errorString())


        
# if __name__ == '__main__':
#     app = QApplication(sys.argv)
#     player = VideoWindow()
#     player.resize(640, 480)
#     player.show()
#     sys.exit(app.exec_())



# import numpy as np                                                     
# import sys
# import time
# from PyQt5.QtGui import QImage, QPainter
# from PyQt5.QtWidgets import QApplication, QWidget
# import threading
# from moviepy.editor import VideoFileClip

# class Demo(QWidget):
#     def __init__(self):
#         super().__init__()
#         self.video = VideoFileClip(r'icon/video1.MP4') # I am using a real video
#         im_np = self.video.get_frame(0)
#         self.image = QImage(im_np, im_np.shape[1], im_np.shape[0],                                                                                                                                                 
#                         QImage.Format_RGB888)
#         self.stopEvent = threading.Event()
#         self.thread = threading.Thread(target=self.display_clip, args=())
#         self.thread.start()

#     def paintEvent(self, event):
#         painter = QPainter(self)
#         painter.drawImage(self.rect(), self.image)

#     def display_clip(self, fps=60):
#         clip = self.video
#         img = clip.get_frame(0) # returns numpy array of frame at time 0

#         t0 = time.time()

#         for t in np.arange(1.0 / fps, clip.duration-.001, 1.0 / fps):
            
#             img = clip.get_frame(t) # returns numpy array of frame at time t
#             # print(img.shape)
#             t1 = time.time()
#             time.sleep(max(0, t - (t1-t0))) # loop at framerate specified
#             self.imdisplay(img) #, screen)
    
#     def imdisplay(self, img_array):
#         # fill the widget with the image array
#         # TODO: Qt widget
#         self.image = QImage(img_array, img_array.shape[1], img_array.shape[0], QImage.Format_RGB888)
#         self.repaint()

# def main():
#     app = QApplication(sys.argv)
#     demo = Demo()
#     demo.show()
#     sys.exit(app.exec_())

# if __name__ == "__main__":
#     main()

# # Import everything needed to edit video clips
# from moviepy.editor import *

# # Load myHolidays.mp4 and select the subclip 00:00:50 - 00:00:60
# clip = VideoFileClip("icon/video2.avi").subclip(20,30)

# # Reduce the audio volume (volume x 0.8)
# clip = clip.volumex(0.8)

# # Generate a text clip. You can customize the font, color, etc.
# # txt_clip = TextClip("My Holidays 2013",fontsize=70,color='white')

# # Say that you want it to appear 10s at the center of the screen
# # txt_clip = txt_clip.set_pos('center').set_duration(10)

# # Overlay the text clip on the first video clip
# video = CompositeVideoClip([clip])
# clip1 = clip.set_start(1) # start after 5 seconds
# # ipython_display(clip) 
# clip.show()
# clip.show(10.5)
# clip.show(10.5, interactive = True)

# # Write the result to a file (many options available !)
# # video.write_videofile("myHolidays_edited.webm")



# from ffpyplayer.player import MediaPlayer

# from PyQt5 import QtGui,QtCore
# from PyQt5.QtWidgets import *
# from PyQt5.QtGui import *
# from PyQt5.QtCore import *
# import sys
# import threading
# import time
# import cv2
# from PIL import Image
# import numpy
# import os

# class VideoPlayer:
#     def __init__(self, filename,volume = 1.0):
#         if not os.path.exists(filename):raise FileNotFound(filename)
#         self.close = False
#         self.state = None
#         self.frame = None
#         self.l=None
#         self.filename = filename
#         self.skip_interval=5

#         self.player = MediaPlayer(filename, ff_opts={'sync': 'audio', 'paused': False, 'volume': volume, 't': 1e7+1, 'ss': 0})
#         time.sleep(1)
#         self.duration=self.player.get_metadata()['duration']
#         handler_thread = threading.Thread(target=self.play, args=(), daemon=True)
#         handler_thread.start()

#     def play(self):
#         while True:
#             frame, self.val = self.player.get_frame()
#             if self.val == 'eof':self.close=True
#             if self.close == True:
#                 self.player.toggle_pause()
#                 self.player.close_player()
#                 time.sleep(2)
#                 break

#             if isinstance(self.val, str) or self.val == 0.0:waitkey = 32
#             else:waitkey = int(self.val * 100)
#             pressed_key = cv2.waitKey(waitkey) & 0xFF

#             if frame is None:continue

#             image, pts = frame
#             self.frame = (image, self.val)
#             x, y = image.get_size()
#             data = image.to_bytearray()[0]
#             image =  Image.frombytes("RGB", (x, y), bytes(data))
#             image = cv2.cvtColor(numpy.array(image), cv2.COLOR_RGB2BGR)
#             self.frame=frame

#             if self.l!=None:
#                 h, w, ch = image.shape
#                 Image2 = QImage(image.data, w, h, ch * w, QImage.Format_RGB888)
#                 self.pixmap=QPixmap.fromImage(Image2)
#                 self.l.setPixmap(self.pixmap)
#                 self.l.setFixedWidth(self.l.pixmap().width())
#                 self.l.setFixedHeight(self.l.pixmap().height())
#                 self.l.parent().update()
#             del image


#     def seek_p(self):
#             if int(self.player.get_pts()) + self.skip_interval < int(self.duration):
#                 self.player.seek(self.skip_interval, relative=True, accurate=False)
#     def seek_m(self):
#         if int(self.player.get_pts()) - self.skip_interval > 0:
#             self.player.seek(-self.skip_interval, relative=True, accurate=False)



# class ed(QWidget):
#     def __init__(self,parent=None):
#         super().__init__()
#         vl=QVBoxLayout()
#         self.setLayout(vl)
#         pb=QPushButton('play');vl.addWidget(pb);pb.clicked.connect(self.play)
#         pb=QPushButton('stop');vl.addWidget(pb);pb.clicked.connect(self.close)
#         pb=QPushButton('pause');vl.addWidget(pb);pb.clicked.connect(self.pause)
#         pb=QPushButton('seek+');vl.addWidget(pb);pb.clicked.connect(self.seek_p)
#         pb=QPushButton('seek-');vl.addWidget(pb);pb.clicked.connect(self.seek_m)
#         pb=QPushButton('mute');vl.addWidget(pb);pb.clicked.connect(self.mute)
#         pb=QPushButton('vol+');vl.addWidget(pb);pb.clicked.connect(self.vol_p)
#         pb=QPushButton('vol-');vl.addWidget(pb);pb.clicked.connect(self.vol_m)
#         self.l=QLabel();vl.addWidget(self.l)
#     def play2(self):
#         self.player=VideoPlayer('icon/video1.mp4')
#         self.player.l=self.l

#     def play(self):
#         self.t1=threading.Thread(target=self.play2)
#         self.t1.start()

#     def pause(self):self.player.player.toggle_pause()
#     def seek_p(self):self.player.seek_p()
#     def seek_m(self):self.player.seek_m()
#     def mute(self):
#         try:
#             if (self.player.player.get_volume()>0.0):self.player.player.set_volume(0.0)
#             else:self.player.player.set_volume(1.0)
#         except:pass
#     def vol_p(self):
#         self.player.player.set_volume(self.player.player.get_volume() + 0.1)
#         print(self.player.player.get_volume())
#     def vol_m(self):
#         self.player.player.set_volume(self.player.player.get_volume() - 0.1)
#         print(self.player.player.get_volume())

#     def close(self):
#         try:
#             self.player.close=True
#             time.sleep(1)
#         except:pass

#     def closeEvent(self, event):
#         try:
#             self.player.close=True
#             time.sleep(1)
#         except:pass



# if __name__ == '__main__':

#     app = QApplication(sys.argv)
#     window=ed()
#     window.showMaximized()
#     sys.exit(app.exec_())
# import os
# def fn():       # 1.Get file names from directory
#     file_list=os.listdir(r"D:\\python infinite")
#     for i in file_list:
#         print(i)

#  #2.To rename files
# fn()
# from zipfile import ZipFile
# import json
# from db_module import *
# import os
# import shutil
# filename='api_data\\demo.zip'
# with ZipFile(filename, 'r') as zipObj:
#    zipObj.extractall(path="api_data\\")

# os.remove(filename)
# import os
# import shutil
# filename='api_data\\demo.zip'
# shutil.unpack_archive(filename,extract_dir="api_data\\")
# os.remove(filename)



# import sys
# from PyQt5.QtWidgets import (QMainWindow, QWidget, QVBoxLayout, 
#                              QApplication, QPushButton)

# class MainWindow(QMainWindow): 
#     def __init__(self, x):                                         # x <-- 3
#         super().__init__()

#         self.centralwidget = QWidget()
#         self.setCentralWidget(self.centralwidget)
#         self.lay = QVBoxLayout(self.centralwidget)

#         for i in range(x):                                          # <---
#             self.btn = QPushButton('Button {}'.format(i +1), self)            
#             text = self.btn.text()
#             self.btn.clicked.connect(lambda ch, text=text : print("\nclicked--> {}".format(text)))
#             self.lay.addWidget(self.btn)

#         self.numButton = 4

#         pybutton = QPushButton('Create a button', self)
#         pybutton.clicked.connect(self.clickMethod)

#         self.lay.addWidget(pybutton)
#         self.lay.addStretch(1)

#     def clickMethod(self):
#         newBtn = QPushButton('New Button{}'.format(self.numButton), self)
#         self.numButton += 1
#         newBtn.clicked.connect(lambda : print("\nclicked===>> {}".format(newBtn.text())))
#         self.lay.addWidget(newBtn)


# if __name__ == "__main__":
#     app = QApplication(sys.argv)
#     mainWin = MainWindow(3)                                            # 3 --> x
#     mainWin.show()
#     sys.exit( app.exec_() )


# import pyudev
# context = pyudev.Context()
# monitor = Monitor.from_netlink()
# # For USB devices
# monitor.filter_by(susbsytem='usb')
# # OR specifically for most USB serial devices
# monitor.filter_by(susbystem='tty')
# for action, device in monitor:
#     vendor_id = device.get('ID_VENDOR_ID')
#     # I know the devices I am looking for have a vendor ID of '22fa'
#     if vendor_id in ['22fa']:
#         print('Detected {} for device with vendor ID {}'.format(action, vendor_id))

#!/usr/bin/env python3

#!/usr/bin/env python3

# import string
# from ctypes import windll
# import time
# import os

# def get_drives():
#     drives = []
#     bitmask = windll.kernel32.GetLogicalDrives()
#     for letter in string.ascii_uppercase:
#         if bitmask & 1:
#             drives.append(letter)
#         bitmask >>= 1
#     return drives


# if __name__ == '__main__':
#     before = set(get_drives())
#     pause = input("Please insert the USB device, then press ENTER")
#     print ('Please wait...')
#     time.sleep(5)
#     after = set(get_drives())
#     drives = after - before
#     delta = len(drives)

#     if (delta):
#         for drive in drives:
#             if os.system("cd " + drive + ":") == 0:
#                 newly_mounted = drive
#                 print ("There were %d drives added: %s. Newly mounted drive letter is %s" % (delta, drives, newly_mounted))
#     else:
#         print ("Sorry, I couldn't find any newly mounted drives.")

import pyudev
from fcntl import *
from pyudev.monitor import Monitor, MonitorObserver
from pyudev._os import pipe, poll
context = pyudev.Context()
monitor = Monitor.from_netlink()
# For USB devices
monitor.filter_by(susbsytem='usb')
# OR specifically for most USB serial devices
monitor.filter_by(susbystem='tty')
for action, device in monitor:
    vendor_id = device.get('ID_VENDOR_ID')
    # I know the devices I am looking for have a vendor ID of '22fa'
    if vendor_id in ['22fa']:
        print('Detected {} for device with vendor ID {}'.format(action, vendor_id))

#!/usr/bin/env python3

#!/usr/bin/env python3

# import subprocess
# import time
# from pathlib import Path

# BLOCK_DEVICE = Path("/dev/sda1")
# MOUNT_POINT = Path("/mnt/TARGET_MOUNTPOINT")
# MOUNT_COMMAND = ["sudo", "mount", BLOCK_DEVICE, MOUNT_POINT]


# def should_mount():
#     """
#     Returns True, if the block_device should be mounted to mount_point
#     """
#     return BLOCK_DEVICE.exists() and not MOUNT_POINT.is_mount()


# def tasks_to_do():
#     """
#     copy files here.
#     may need sudo if the USB drive is FAT, exFAT, or NTFS
#     may want to umount once done but that will trigger
#     the mount and copy next time through the loop
#     """


# while True:
#     if should_mount():
#         try:
#             # catch possible CalledProcessError.
#             # sudo can fail and mount could fail
#             subprocess.check_call(MOUNT_COMMAND)
#         except subprocess.CalledProcessError:
#             print(f"Could not mount {BLOCK_DEVICE} at {MOUNT_POINT}")
#         else:
#             tasks_to_do()

#     time.sleep(1)



